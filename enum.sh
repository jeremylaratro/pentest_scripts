#!/bin/bash
# Jeremy Laratro - Bash Network & Web Enumeration Automation Script 

# init variables
ip=""
domain=""

RRED="\e[31m"
RED="31"
GREEN="32"
RGREEN="\e[32m"
BOLDGREEN="\e[1;${GREEN}m"
BOLDRED="\e[1;${RED}m"
ITALICRED="\e[3;${RED}m"
ENDCOLOR="\e[0m"

help() {
  cat << EOF
Usage: $(basename "$BASH_SOURCE") [OPTIONS]

Options:
  -i IP_ADDRESS   Specify the IP address for scanning.
  -d DOMAIN       Specify the domain for directory/DNS functions.
  -a              Perform all actions.
  -w		  Perform web enumeration.
  -s		  Perform subdomain enumeration.
  -n		  Perform network enumeration.
  -h              Show this help message.
  
Example:
  $(basename "$BASH_SOURCE") -i ip_address -d example.com -a
EOF
}

opts='i:d:x:swnabh'
while getopts $opts arg; do
  case $arg in
    i ) ip=$OPTARG;;
    d ) domain=$OPTARG;;
    s ) sub=1;;
    w ) web=1;;
    n ) network=1;;
    a ) all=1;;
    h ) help=1;;
    * ) echo "unknown argument";;
  esac
done


argcheck() {
  # if both IP and domain are provided, use domain for DNS/directory and IP for scanning.
  if [ ! -z "$ip" ] && [ ! -z "$domain" ]; then
    echo "Both IP and domain have been provided."
    echo "IP for network scanning: $ip"
    echo "Domain for DNS/directory functions: $domain"
    export SCAN_TARGET=$ip
    export DNS_TARGET=$domain
  # if only IP is provided, use it for both scanning and DNS/directory functions.
  elif [ ! -z "$ip" ]; then
    echo "Only IP has been provided."
    echo "Using IP for both scanning and DNS/directory functions: $ip"
    export SCAN_TARGET=$ip
    export DNS_TARGET=$ip
  elif [ ! -z "$domain" ]; then
    echo "Only domain has been provided."
    #resolve_domain "$domain"
    export SCAN_TARGET=$RESOLVED_IP
    export DNS_TARGET=$domain
  else
    echo "No IP or domain provided. Exiting."
    exit 1
  fi
}

resolve_domain() {
  RESOLVED_IP=$(host "$1" | awk '/has address/ { print $4 }')
  if [ -z "$RESOLVED_IP" ]; then
    RESOLVED_IP=$ip
  else
    echo "Domain $1 resolved to IP: $RESOLVED_IP"
  fi
}

initialize_file_struct(){
  echo $pwd
  echo "Creating directory in "$pwd
  if [ -d 'output/scan_$ip' ]
  then
    echo 'Directory already exists, moving on.'
  else
    echo 'Creating output directory'
    mkdir output/scan_$ip 
  fi
  touch output/scan_$ip/web_scan_$ip.txt
  touch output/scan_$ip/inital_$ip.txt
  touch output/scan_$ip/open.txt
  touch output/scan_$ip/rports_$ip.txt
  #output/scan_$ip/vulnchk_$ip.xml
  web_out=output/scan_$ip/web_scan_$ip.txt
  LOGFILE=output/scan_$ip/inital_$ip.txt
  LOG2=output/scan_$ip/vulnchk_$ip.xml
  echo 'Created: '$(ls output/scan_$ip)
  export rports=output/scan_$ip/rports_$ip.txt
  export open=output/scan_$ip/open.txt

}

network(){
  # perform a full TCP port scan using rustscan
  for i in $(seq 1 10); do echo -n "---"; sleep 0.05; done;
  echo -ne '\n'
  echo " Starting full port scan.."
  rustscan -a $SCAN_TARGET --ulimit 5000 -g > $rports
  cat $rports | awk '/->/{print $3}' | tr -d '[]' | tr "," "\n" |tr -d "^ " > $open
  # take the findings from rustscan and then perform a targeted fingerprinting scan with nmap
  ropen=$(cat $rports | awk '/->/{print $3}' | tr -d '[]') 
  for i in $(seq 1 10); do echo -n "---"; sleep 0.05; done;
  echo -ne '\n'
  echo 'The following ports are open: '$ropen
  sudo nmap -sS -sV -sC $SCAN_TARGET -p "$(echo $ropen)" -oX $LOG2 -oG $LOGFILE
  for i in $(seq 1 10); do echo -n "---"; sleep 0.05; done;

}

web_server_discovery() {
 # echo "Starting web discovery"
  #for i in $(seq 1 10); do echo -n "---"; sleep 0.05; done;
  #cat $LOGFILE | grep -o '[0-9]\{1,6\}/open/' | awk -F/ '{print$1}' > open.txt
  # length method
  #threshold_length=50
  port_input_file="output/scan_$SCAN_TARGET/open.txt" 
  while IFS= read -r port <&3; do
    echo "Checking for webserver on $ip:$port"
    status=$(httpx -silent -status-code -no-color -target "http://$ip:$port" | grep -oP '\[\K\d+(?=\])')
  
    if [[ ! -z $status ]]; then
      echo "Webserver detected on port $port with status code: $status"
      echo $port >> output/scan_$SCAN_TARGET/websrv.txt
    else
      echo "No webserver detected on port $port."
    fi
  done 3< "$port_input_file" 
  echo "Scan complete. Results saved to output/scan_$ip/websrv.txt"
}

smb_scan() {
  echo "\n"
  echo "Checking for standard SMB service to scan with enum4linux"
  if grep -q -E '(^|, )139(,|$)|(^|, )445(,|$)' $rports; then
    echo "Found open SMB ports"
    echo " "
    enum4linux $SCAN_TARGET
  else echo 'SMB not found'
  echo "\n"
     
  fi
}

searchsploit_check() (
  echo -n "Checking for known exploits..."
  for i in seq{1..10}; do
    echo -n "."
    sleep 0.15s
  done
  echo " "
  ssh_() {
    if (cat $LOG2 | grep -q 'ssh'); then
      rm srch.txt
      touch srch.txt
      cat $LOG2 | grep 'ssh' | grep -o 'product=".*"' | cut -d \" -f2 | grep -o '^\S*'  > srch.txt
      cat $LOG2 | grep 'ssh' | grep -oE 'version="[0-9]?.[0-9]?.' | grep -Eo '[0-9]?.[0.9]..' >> srch.txt
      vv=$(cat srch.txt)
      if [ ! -z srch.txt ]; then
        echo 'Searching exploitdb for' $vv
        searchsploit $vv
        # echo 'Analyzing ssh vulnerabilities'
        # nmap $ip --script=ssh-\* -v
        echo ' '
        
      else
        echo ' '
      fi
    else
      echo ' '
    fi
  }
  ssh_
  
  ftp_() {
    if (cat $LOG2 | grep -q 'ftp'); then
  	rm srch.txt
  	touch srch.txt
  	cat $LOG2 | grep 'ftp' | grep -o 'product=".*"' | cut -d \" -f2 | grep -o '^\S*'  > srch.txt
  	cat $LOG2 | grep 'ftp' | grep -oE 'version="[0-9]?.[0-9]?.' | grep -Eo '[0-9]?.[0.9]..' >> srch.txt
  	vv=$(cat srch.txt)
  	if [ ! -z srch.txt ]; then
  		echo 'Searching exploitdb for' $vv
  		searchsploit $vv
  		echo ' '
  		
  	else
  		echo ' '
  	fi
    else
      echo ' '
    fi
  }
  ftp_
  
  smb_() {
    if (cat $LOG2 | grep -q 'smb'); then
  	rm srch.txt
  	touch srch.txt
  	cat $LOG2 | grep 'smb' | grep -o 'product=".*"' | cut -d \" -f2 | grep -o '^\S*'  > srch.txt
  	cat $LOG2 | grep 'smb' | grep -oE 'version="[0-9]?.[0-9]?.' | grep -Eo '[0-9]?.[0.9].' >> srch.txt
  	vv=$(cat srch.txt)
  	if [ ! -z srch.txt ]; then
  		echo 'Searching exploitdb for' $vv
  		searchsploit $vv
  		echo ' '
  		echo 'Analyzing smb vulnerabilities'
          nmap $ip --script=smb-vuln\* -v
          echo ' '
  		
  	else
  		echo ' '
  	fi
    else
      echo ' '
    fi
  }
  smb_
  
  web_() {
    if (cat $LOG2 | grep -q 'http'); then
  	rm srch.txt
  	touch srch.txt
  	cat $LOG2 | grep 'http' | grep -o 'product=".*"' | cut -d \" -f2 | cut -d " " -f1,2  > srch.txt
  	cat $LOG2 | grep 'http' | grep -oE 'version="[0-9]?.[0-9]?.' | grep -Eo '[0-9]?.[0.9].' >> srch.txt
  	vv=$(cat srch.txt)
  	if [ ! -z srch.txt ]; then
  		echo 'Searching exploitdb for' $vv
  		searchsploit $vv
  		echo ' '
  		echo 'Analyzing http vulnerabilities'
          nmap $ip --script=http-vuln\* -v
          echo ' '
  		
  	else
  		echo ' '
  	fi
    else
      echo ' '
    fi
  }
  web_
)


directory_enumeration(){
  for i in $(seq 1 10); do echo -n "---"; sleep 0.05; done;
  echo -ne '\n'
  echo "Starting web directory enumeration"
  websrv_input_file="output/scan_$ip/websrv.txt"
  while IFS= read -r wport <&3; do
    if [ $DNS_TARGET ]; then 
      echo 'DNS'
      gospider -s http://$DNS_TARGET:$wport
      gobuster dir -u http://$DNS_TARGET:$wport --wordlist /usr/share/dirb/wordlists/big.txt 
    else
      echo 'ip' 
      gospider -s http://$SCAN_TARGET:$wport
      gobuster dir -u http://$SCAN_TARGET:$wport --wordlist /usr/share/dirb/wordlists/big.txt 
    fi
  done 3< "$websrv_input_file"    
}


dns_enum() {
  if [ $DNS_TARGET ]; then
    dig ANY $domain @$SCAN_TARGET
    dig ANY $domain
  else
    dig ANY $ip
  fi
  #  vhost subdomain enum
  timeout 5 wfuzz -c -w $wordlists/SecLists/Discovery/DNS/subdomains-top1million-20000.txt -H "Host: FUZZ.$DNS_TARGET" http://$DNS_TARGET > initial_fuzz.txt
  hide=$(cat initial_fuzz.txt | grep -v "404" | awk '{print $4}' | uniq | grep -Po '[0-9]')
  echo $hide
  wfuzz -c -w $wordlists/SecLists/Discovery/DNS/subdomains-top1million-20000.txt --hl $hide -H "Host: FUZZ.$DNS_TARGET" http://$DNS_TARGET 
  gobuster dns -d $DNS_TARGET -w $wordlists/SecLists/Discovery/DNS/subdomains-top1million-20000.txt
}


formatter() {
  #cat vulnchk_10.11.1.111.xml| grep -Po 'portid="*[0-9]+."' | tr -d 'portid="' | sed 's/$/,/' | tr -d '\n' >> report_$ip.txt
  echo 'Target: '$SCAN_TARGET 
  echo 'Hostname: '$DNS_TARGET
  echo 'TCP: ' && cat $rports |  awk '/->/{print $3}' | tr -d '[]' 
}


main() {
  initialize_file_struct
  argcheck

  # check if either ip or domain is provided
  if [ -z "$ip" ] && [ -z "$domain" ]; then
    echo "Please provide either -i or -d option"
    exit 1
  fi
  
  if [ ! -z "$network" ]
  then
    echo "Starting network scan.."
    echo " " 
    network
    searchsploit_check 
  fi
  
  if [ ! -z "$help" ]
  then
    help
  fi
  if [ ! -z "$sub" ]
  then
    echo "Starting DNS discovery"
    dns_enum
  fi
  
  if [ ! -z "$smb" ]
  then
    smb_scan
  fi
  
  if [ ! -z "$web" ]
  then
    web_server_discovery
    directory_enumeration
    
  fi
  if [ ! -z "$all" ]
  then
    echo -e "${BOLDGREEN}All commands enabled${ENDCOLOR}"
    network
    searchsploit_check
    web_server_discovery
    dns_enum
    smb_scan
    directory_enumeration
  fi
}

main

# CHANGELOG
# v1.00  
#	- Major update. Complete refactoring. Started changelog. 
#	- Removed old, commented code 
#	- Removed unecessary switches and consolidated the choices
#	- Made network into one function, using both rustscan and nmap
#	- Greatly improved the method of parsing domain vs ip and handling of both
#	- Added better dns enum, added vhost fuzzing (especially useful for HTB!)
# 	- Cleaned up code and improved functions where possible 



